use warnings;
use strict;
use Getopt::Long;
use Bio::SeqIO;
use Bio::TreeIO;
use Digest::MD5 qw(md5 md5_hex md5_base64);

my $start_stage;
my $genomes_file_1;
my $pegs_file_1;
my $genomes_file_2;
my $pegs_file_2;
my $m8_file;
my $dice_file;
my $tree_file;
my $node_stats_file;
my $threads = 1;
my $max_lineage_reps = 999_999;
my $min_lineage_reps = 20;
my $max_cutoff = 100;
my $min_cutoff = 0.0014;
my $node_var = "Node_Depth";
my $ref_info_file;
my $file_prefix = "GLUVAB";
my $help;


GetOptions(
'file_prefix=s' => \$file_prefix,
'genomes_file_1=s' => \$genomes_file_1,
'pegs_file_1=s' => \$pegs_file_1,
'genomes_file_2=s' => \$genomes_file_2,
'pegs_file_2=s' => \$pegs_file_2,
'm8_file=s' => \$m8_file,
'dice_file=s' => \$dice_file,
'tree_file=s' => \$tree_file,
'ref_info_file=s' => \$ref_info_file,
'node_stats_file=s' => \$node_stats_file,
'threads=s' => \$threads,
'min_lineage_reps=s' => \$min_lineage_reps,
'max_lineage_reps=s' => \$max_lineage_reps,
'max_cutoff=s' => \$max_cutoff,
'min_cutoff=s' => \$min_cutoff,
'node_variable=s' => \$node_var,
'help' => \$help
);

die "
GLUVAB Genomic Lineages of Uncultured Viruses of Archaea and Bacteria
    Copyright (C) 2019  Felipe Hernandes Coutinho (felipehcoutinho\@gmail.com)

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.


	
Usage:
--help | Print this help message and exit.
--file_prefix | String to be added to the output files (Default: GLUVAB)
--threads | Number of threads to be used during Diamond search (Default: 1)

\tLineage identification criteria:
--min_lineage_reps | Minimum number of representatives in a tree node to establish a valid lineage (Default: 50).
--max_lineage_reps | Maximum number of representatives in a tree node to establish a valid lineage (Default: 999999).
--node_variable | Which node variable to use when defining lineages. One of  Average_Node_Distances, Node_Depth or Node_Height (Default: Node_Depth).
--max_cutoff | Maximum value of the selected node variable of a node to establish a valid lineage (Default: 100).
--min_cutoff | Minimum value of the selected node variable of a node to establish a valid lineage (Default: 0.0014).

\tInput files:
--genomes_file_1 | Fasta format file containing DNA sequences of viral genomes to be analyzed
--pegs_file_1 | Fasta format file containing protein sequences derived from viral genomes.\n\tSequences MUST be named as the Id of the original genomic sequence followed by _SEQNUM. \n\tExample: Scaffold_1_1, Scaffold_1_2, Scaffold_1_3, GenomeA_1, GenomeA_2...
--m8_file | M8 format file containing the results of the all-versus-all protein search generated by Diamond. MUST use the same nomeclature as for the pegs file
--dice_file | tsv format file containing the Dice distances among genomes
--tree_file | Newick format file of the tree built based on the Dice distances
--node_stats_file | tsv format file containing the average Dice distances within each node of the tree
--ref_info_file | tsv format file containing the taxonomic classification or lineage assignment of sequences in dataset1 to be used when performing closets relative classification

The order in which analyses are performed is:

1) Identify protein encoding genes in the genomes file with Prodigal (provide --genomes_file_1).
2) Perform all-verus-all search of protein encoding genes using Diamond (provide --pegs_file_1).
3) Calculate Dice distances between genomes based on the output of the diamond search (provide --m8_file).
4) Build Neighbor-Joining tree based on Dice distances (provide --dice_file).
5) Calculate statistics of Dice distances for each node of the tree (provide --tree_file and --dice_file).
6) Identify lineages in the tree (provide --tree_file and --node_stats_file).

#####################################################################################

Optional: To classify sequences in dataset2 according to their closest relative (CR) 
in dataset1 based on average amino acid identity (AAI) and percentage of matched protein encoding genes
(provide --genomes_file_1 and --genomes_file_2) or (--pegs_file_1 and --pegs_file_2).
Optionally provide --ref_info_file to the output table includes de taxonomic classification / lineage assignment of the CR

#####################################################################################

Providing a file other than the --genomes_file_1 will skip all of
the previous steps and start the analysis according to the provided file.

#####################################################################################

Dependencies:
BioPerl
Perl modules: Digest::MD5

Prodigal (v2.60)
DIAMOND (v0.9.14)
R (v3.2.5)
R libraries: phangorn
" if $help;

my %seq_info;
my %ref_info;

central();

sub central {
	define_stage();
	index_genome_seqs() if ($start_stage <= 1);
	call_prodigal() if ($start_stage <= 1);
	index_peg_seqs($pegs_file_1) if ($start_stage <= 2);
	call_diamond() if ($start_stage <= 2);
	calc_scores() if ($start_stage <= 3);
	build_tree() if ($start_stage <= 4);
	calc_tree_node_stats() if ($start_stage <= 5);
	define_lineages()if ($start_stage <= 6);
	classif_aai_perc() if ($start_stage == 7);
	
	my $seq_info_file_name = $file_prefix."_Seq_Info.tsv";
	my %params = ("matrix" => \%seq_info, "file" => $seq_info_file_name);
	print_matrix(\%params);
}

sub define_stage {
	$start_stage = 1 if (defined $genomes_file_1);
	$start_stage = 2 if (defined $pegs_file_1);
	$start_stage = 3 if (defined $m8_file);
	$start_stage = 4 if (defined $dice_file);
	$start_stage = 5 if ((defined $tree_file) and (defined $dice_file));
	$start_stage = 6 if ((defined $tree_file) and (defined $node_stats_file));
	$start_stage = 7 if ((defined $genomes_file_1) and (defined $genomes_file_2));
	$start_stage = 7 if ((defined $pegs_file_1) and (defined $pegs_file_2));
		
	die "Must provide at least one of: --genomes_file_1, --pegs_file_1 --m8_file, --dice_file, --tree_file and --dice file, --tree_file and --node_stats_file,  --genomes_file_1 and  --genomes_file_2 and --ref_info_file, --pegs_file_1 and  --pegs_file_2 and --ref_info_file\n" unless ((defined $start_stage) and ($start_stage >= 1));
}


sub classif_aai_perc {
	
	unless (defined $pegs_file_1) {
		$pegs_file_1 = $file_prefix."_1_PEGs";
		print "Running Prodigal for $genomes_file_1\n";
		system("prodigal -q -n -p meta -a $pegs_file_1.faa -d $pegs_file_1.fna -f gff -i $genomes_file_1 -o $pegs_file_1.gff");
		$pegs_file_1 = $pegs_file_1.".faa";
	}
	index_peg_seqs($pegs_file_1);
	
	unless (defined $pegs_file_2) {
		$pegs_file_2 = $file_prefix."_2_PEGs";
		print "Running Prodigal for $genomes_file_2\n";
		system("prodigal -q -n -p meta -a $pegs_file_2.faa -d $pegs_file_2.fna -f gff -i $genomes_file_2 -o $pegs_file_2.gff");
		$pegs_file_2 = $pegs_file_2.".faa";
	}
	index_peg_seqs($pegs_file_2);
	
	print "Running Diamond\n";
	system("diamond makedb --in $pegs_file_1 --db $pegs_file_1");
	$m8_file = $pegs_file_1."x".$pegs_file_2.".blastp";
	$m8_file =~ s/\.faa//g;
	system("diamond blastp --matrix BLOSUM45 --threads $threads --more-sensitive --db $pegs_file_1 --outfmt 6 --query $pegs_file_2 --max-target-seqs 999999 --id 30 --evalue 0.001 --out $m8_file");
	
	print "Computing Scores\n";
	my %seen_combos;
	my %seen_pegs;
	my %hits_info;
	
	my $hit_counts = 0;
	my $shouter = 1;
	print "Parsing Diamond output\n";
	open INPUT, "< $m8_file" or die "$!";
	while (my $line = <INPUT>) {
		$hit_counts++;
		if ($hit_counts == $shouter) {print "Processed $hit_counts hits\n"; $shouter += $shouter }
		chomp $line;
		my @values = split /\t/, $line;

		#Ignore hits with less than 30% id, less than 30 of alignment length and evalue higher than 0.01
		next if (($values[2] < 30) or ($values[3] < 30) or ($values[10] > 0.01));
		
		my $peg_A = $values[0];
		my $peg_B = $values[1];
		
		next if ($peg_A eq $peg_B);
		
		my $scaffold_A = $values[0];
		my $scaffold_B = $values[1];
		
		$scaffold_A =~ s/-cds\d+//;
		$scaffold_A =~ s/_\d+$//;
		$scaffold_B =~ s/-cds\d+//;
		$scaffold_B =~ s/_\d+$//;

		
		next if (defined $seen_combos{$peg_A}{$scaffold_B});
		$seen_combos{$peg_A}{$scaffold_B} = 1;
		
		my $best_count = 0;
		unless ((defined $seen_pegs{$peg_A}) or ($scaffold_A eq $scaffold_B)) {$best_count = 1; $seen_pegs{$peg_A} = 1};
		
		$hits_info{"id_sum"}{$scaffold_A}{$scaffold_B}+= $values[2];
		$hits_info{"hit_count"}{$scaffold_A}{$scaffold_B}++;
		$hits_info{"score_sum"}{$scaffold_A}{$scaffold_B}+= $values[11];
		$hits_info{"best_hits"}{$scaffold_A}{$scaffold_B}+= $best_count;
		
		}
	close INPUT;
	
	
	if (defined $ref_info_file) {
		print "Reading in $ref_info_file\n";
		my %params = ("file" => $ref_info_file);
		my $ref_info_ref = read_table(\%params);
		%ref_info = %$ref_info_ref;
	}
	
	print "Calculating pairwise Scaffold Scores\n";
	#Run over all the scaffold taxon combinations to measure AAI and identify CRs
	my $recip_score_file_name = $file_prefix."_Scaffold_Recip_Scores.tsv";
	open OUT, "> $recip_score_file_name" or die "$!";
	print OUT "Scaffold_A\tScaffold_B\tHit_counts\tBest_hits\tScaffold_Total_PEGs\tAAI\tBitScore_Sum\tPercent_Matched_PEGs\tPercent_Best_Hits\n";
	
	my $combo_counts = 0;
	$shouter = 1;
	
	#Get the complete list of taxa and all scaffolds to iterate over;
	my $scaff_ref = $hits_info{"hit_count"};
	my %scaff_list = %$scaff_ref;
	foreach my $scaffold_A (keys %scaff_list) {
		my $subj_list_ref = $hits_info{"hit_count"}{$scaffold_A};
		my %subject_list = %$subj_list_ref;
		unless (defined $seq_info{"PEG_Count"}{$scaffold_A}) {
			print "No PEG counts defined for scaffold $scaffold_A\n";
			next;
		}
		next if ($seq_info{"PEG_Count"}{$scaffold_A} <= 0);
		
		foreach my $scaffold_B (keys %subject_list) {
			$combo_counts++;
			if ($combo_counts == $shouter) {print "Processed $combo_counts combinations\n"; $shouter += $shouter }
			
			#Some Tax Scaffold combinations will never be defined and there is nothing to do with them
			unless ((defined $hits_info{"hit_count"}{$scaffold_A}{$scaffold_B}) and (defined $hits_info{"id_sum"}{$scaffold_A}{$scaffold_B}) and ($hits_info{"score_sum"}{$scaffold_A}{$scaffold_B})) {
				print "Skipping Pair $scaffold_A $scaffold_B because hits info is incomplete"; 
				next
			}
			
			next if ($hits_info{"id_sum"}{$scaffold_A}{$scaffold_B} <= 0);
			next if ($hits_info{"hit_count"}{$scaffold_A}{$scaffold_B} <= 0);
			next if ($hits_info{"score_sum"}{$scaffold_A}{$scaffold_B} <= 0);
			
			my $aai_value = ($hits_info{"id_sum"}{$scaffold_A}{$scaffold_B} / $hits_info{"hit_count"}{$scaffold_A}{$scaffold_B});
			$hits_info{"AAI"}{$scaffold_A}{$scaffold_B} = $aai_value;
			#$aai_table{$scaffold_B}{$scaffold_A} = $aai_value;
			
			my $perc_matched_pegs = ($hits_info{"hit_count"}{$scaffold_A}{$scaffold_B} /$seq_info{"PEG_Count"}{$scaffold_A}) * 100;
			$hits_info{"Perc_Matched_PEGs"}{$scaffold_A}{$scaffold_B} = $perc_matched_pegs;
			
			my $perc_best_hits = ($hits_info{"best_hits"}{$scaffold_A}{$scaffold_B} /$seq_info{"PEG_Count"}{$scaffold_A}) * 100;
			$hits_info{"Perc_Best_Hits"}{$scaffold_A}{$scaffold_B} = $perc_best_hits;
			
			update_cr($scaffold_A,$scaffold_B,$aai_value,$perc_matched_pegs,$hits_info{"hit_count"}{$scaffold_A}{$scaffold_B}) unless (defined $seq_info{"CR_ID"}{$scaffold_A}); 
		
			if ($perc_matched_pegs > $seq_info{"CR_Perc_Matched_PEGs"}{$scaffold_A}) {
				update_cr($scaffold_A,$scaffold_B,$aai_value,$perc_matched_pegs,$hits_info{"hit_count"}{$scaffold_A}{$scaffold_B});
			} elsif (($perc_matched_pegs == $seq_info{"CR_Perc_Matched_PEGs"}{$scaffold_A}) and ($aai_value > $seq_info{"CR_AAI"}{$scaffold_A})) {
				update_cr($scaffold_A,$scaffold_B,$aai_value,$perc_matched_pegs,$hits_info{"hit_count"}{$scaffold_A}{$scaffold_B});
			}
			
			my $line = join ("\t",$scaffold_A,$scaffold_B,$hits_info{"hit_count"}{$scaffold_A}{$scaffold_B},$hits_info{"best_hits"}{$scaffold_A}{$scaffold_B},$seq_info{"PEG_Count"}{$scaffold_A},$hits_info{"AAI"}{$scaffold_A}{$scaffold_B},$hits_info{"score_sum"}{$scaffold_A}{$scaffold_B},$hits_info{"Perc_Matched_PEGs"}{$scaffold_A}{$scaffold_B},$hits_info{"Perc_Best_Hits"}{$scaffold_A}{$scaffold_B});
			
			print OUT "$line\n" if ($hits_info{"Perc_Matched_PEGs"}{$scaffold_A}{$scaffold_B} >= 30);
			
			}
		}
	close OUT;
}

sub update_cr {
	my ($scaffold_A,$scaffold_B,$aai_value,$perc_matched_pegs,$hit_count) = @_;
	$seq_info{"CR_ID"}{$scaffold_A} = $scaffold_B;
	$seq_info{"CR_AAI"}{$scaffold_A} = $aai_value;
	$seq_info{"CR_Perc_Matched_PEGs"}{$scaffold_A} = $perc_matched_pegs;
	$seq_info{"CR_Matched_PEGs"}{$scaffold_A} = $hit_count;
				
	foreach my $field (keys %ref_info) {
		if ($field =~ /Lineage|Order|Family|Genus|Species|Host/i) {
			if (defined $ref_info{$field}{$scaffold_B}) { $seq_info{"CR_$field"}{$scaffold_A} = $ref_info{$field}{$scaffold_B} }
			}
	}
	
}

sub define_lineages {
	my $lineage_prefix = "Lineage";
	#Read in the file containing node info
	print "Reading in $node_stats_file\n";
	my %params = ("file" => $node_stats_file);
	my $info_ref = read_table(\%params);
	my %info = %$info_ref;
	
	my $lineage_count = 0;
	my %leaf2lineage;
	my %lineage_info;


	print "Opening $tree_file\n";
	#Open reference tree for parsing parse in newick/new hampshire format
	my $tree_parser = new Bio::TreeIO(-file   => $tree_file, -format => "newick");
	#A copy of the reference tree but containing node ids will be printed out
	my $annot_tree_file = $file_prefix."_Tree_With_node_IDs.newick";
	my $out = new Bio::TreeIO(-file => ">$annot_tree_file", -format => 'newick');

	my $tree_obj = $tree_parser->next_tree;
	my @nodes = $tree_obj->get_nodes;

	my $node_count = -1;

	print "Defining lineages\n";
	open OUT1, "> $file_prefix-Node_to_Lineage.tsv" or die "$!";
	
	foreach my $node (@nodes) {
		$node_count++;
		next if ($node->is_Leaf);
		$node->id("Node_$node_count") unless ($node->is_Leaf);
		#Check for node info in the table. Die if not defined 
		die "No Depth info defined for node $node_count\n" unless (defined  $info{"Node_Depth"}{$node_count});
		die "No Height info defined for node $node_count\n" unless (defined  $info{"Node_Height"}{$node_count});
		die "No MD5_ID info defined for node $node_count\n" unless (defined  $info{"MD5_ID"}{$node_count});
		die "No distances info defined for node $node_count\n" unless (defined $info{"Average_Node_Distances"}{$node_count});
		
		#Skip nodes for each no distance value is available. 
		if ($info{$node_var}{$node_count} eq "NA") { next }
		
		my $depth = $node->depth;
		my $height = $node->height;
		print "Height mismatch for node $node_count: $height (Tree)| $info{Node_Height}{$node_count} (Table)!!\n" if ($height ne $info{"Node_Height"}{$node_count});
		print "Depth mismatch for node $node_count: $depth (Tree)| $info{Node_Depth}{$node_count} (Table)!!\n" if ($depth ne $info{"Node_Depth"}{$node_count});
		 
		 
		my @children = $node->get_all_Descendents;
		my %children_ids;
		my $skip_node = 0;

		foreach my $child (@children) {
			next unless ($child->is_Leaf);
			$children_ids{$child->id} = 1;
			if (defined $leaf2lineage{$child->id}) {$skip_node = 1 ; last}
		}
		
		if ($skip_node) { next}
		
		my @children_ids = sort keys %children_ids;
		my $children_count = @children_ids;

		#Get the MD5 Sum of children IDS
		my $md_id;
		if ($children_count == 0) {
			my $leaf_name = $node->id;
			$md_id = md5_hex($leaf_name);
		} else {
			$md_id = md5_hex(@children_ids);
		}

		die "Mismatch in MD5_ID for Node $node_count!\n" if ($info{"MD5_ID"}{$node_count} ne $md_id);
		#Skip nodes that dont have enough children to be defined as a lineage
		if (($children_count < $min_lineage_reps) or ($children_count > $max_lineage_reps)) { next}
		
		#Check if node can be a lineage based on distance cutoff
		if (($info{$node_var}{$node_count} <= $max_cutoff) and ($info{$node_var}{$node_count} >= $min_cutoff)) {
			print "\tFound a lineage: $lineage_prefix"."_$lineage_count with $children_count leaves. Average Distances: $info{Average_Node_Distances}{$node_count} Height: $height Depth: $depth\n";
			print OUT1 "Node_$node_count\t"."$lineage_prefix"."_$lineage_count\n";
			#Print Assignment of leaves to output file
			foreach my $child (@children_ids) {
				die "WARNING!! Lineage has already been defined for $child: $leaf2lineage{$child} node $node_count\n" if (defined $leaf2lineage{$child});
				$leaf2lineage{$child} = "$lineage_prefix"."_$lineage_count";
				$seq_info{"Lineage_$node_var-min_cutoff_$min_cutoff-max_cutoff_$max_cutoff-Min_Reps_$min_lineage_reps"}{$child} = "$lineage_prefix"."_$lineage_count";
			}
			$lineage_count++;
		}
		

	}

	#Print out the copy of the tree containing node ids
	$out->write_tree($tree_obj);
	#Count and print the number of genomes assigned to lineages
	my $count = keys %leaf2lineage;
	print "$count leaves assigned to lineages\n";

	close OUT1;
}


sub calc_tree_node_stats {
	print "Opening tree\n";
	# parse in tree
	my $tree_parser = new Bio::TreeIO(-file   => $tree_file, -format => "newick");
	my $tree_obj = $tree_parser->next_tree;
	my @nodes = $tree_obj->get_nodes;

	#Get distances from Dice file
	print "Opening Distance matrix\n";
	my %params = ("file" => $dice_file);
	my $distance_ref = read_table(\%params);
	my %dists = %$distance_ref;

	$node_stats_file = $file_prefix."_Tree_Node_Stats.tsv";
	
	open OUT, "> $node_stats_file" or die "$!";
	print OUT "Node_ID\tIs_Leaf\tLeaf_ID\tChildren_Count\tNode_Depth\tNode_Height\tAverage_Node_Distances\tMD5_ID\n";
	my $node_count = -1;
	my $shouter = 1;
	my $root_node;
	print "Parsing tree\n";
	foreach my $node (@nodes) {
		$node_count++;
		#Keep track of the root node
		unless ($root_node) {$root_node = $node};
		if ($node_count == $shouter) { print "Processed $node_count nodes\n"; $shouter+= $node_count}
		#Check if node is a leaf
		my $leaf_status = $node->is_Leaf;
		if ($leaf_status) {$leaf_status = "TRUE"} else {$leaf_status = "FALSE"};
		my @children = $node->get_all_Descendents;
		my $children_count = 0;
		my @leaves;
		
		#Count the number of leaves for each node
		foreach my $child (@children) {
			next unless ($child->is_Leaf);
			$children_count++;
			push @leaves, $child->id;
		}
		
		#Generate the MD5 Sum based on the sorted names of node leaves
		my @sorted_leaves = sort (@leaves);
		my $md_id = "NA";
		if ($children_count == 0) {
			my $leaf_name = $node->id;
			$md_id = md5_hex($leaf_name);
		} else {
			$md_id = md5_hex(@sorted_leaves);
		}

		#Calculate basic node stats: depth, height,length and distance fromm root if requested
		my $depth = $node->depth;
		my $height = $node->height;
		#my $length = $node->branch_length;
		my $root_dist =  "NA"; 
		
		
		#Calculate stats of node distances
		my ($mean,$median,$sd,$max,$min) = qw(NA NA NA NA NA);
		my $dist_sum = 0;
		my $combos = 0;
		my %seen;
		my @all_dists;
		
		#To speed the process up nodes with too many leaves are skipped
		if ($children_count <= $max_lineage_reps) {
			foreach my $leaf1 (@leaves) {
				foreach my $leaf2 (@leaves) {
					#Skip repeated pairs
					next if (defined $seen{$leaf1}{$leaf2});
					#Skip the distance between a leaf to iteself (it should always be 0)
					next if ($leaf1 eq $leaf2);
					$seen{$leaf1}{$leaf2} = 1; $seen{$leaf2}{$leaf1} = 1;
					#If there is no distance defined for the pair in the distance matrix this is a serious issue and the program should die
					die "No distance defined for pair: $leaf1 $leaf2\n" unless (defined $dists{$leaf1}{$leaf2});
					#Keep track of the combos (numbers of noon redundant leaf pairs to make sure all is going right)
					$combos++;
					#The the distance of the pair to the total the sum of the node
					$dist_sum += $dists{$leaf1}{$leaf2};
					push (@all_dists,$dists{$leaf1}{$leaf2});
				}
			}
			
		} else {
			print "WARNING! To speed up calculations nodes with more than $max_lineage_reps leaves will be skipped!\n"
		}
		
		#calculate average again with a different function just to be safe
		my $avg_dists = "NA";
		$avg_dists = $dist_sum / $combos if ($combos > 0);
		
		#Fetch the ID of leaf nodes
		my $leaf_id = "NA";
		$leaf_id = $node->id if ($leaf_status eq "TRUE");
		
		#Print stats to output
		
		my $string = join("\t",$node_count,$leaf_status,$leaf_id,$children_count,$depth,$height,$avg_dists,$md_id);
		print OUT "$string\n";
	}
	close OUT;
}

sub build_tree {
	open OUT, "> Make_Dice_NJ_Tree.R";
	print OUT
'args = commandArgs(trailingOnly=TRUE)
dice_matrix<-args[1]
out_tree<-args[2]
library(phangorn)
data<-read.table(file=dice_matrix,sep="\t",header=TRUE,comment="",quote="")
rownames(data)<-data[,1]
data<-data[,-1]
distances<-as.dist(data)
dice_tree<-NJ(distances)
dice_tree<-midpoint(dice_tree)
write.tree(dice_tree,file =out_tree)';
	close OUT;

	$tree_file = $file_prefix."_Dice_Tree.newick";
	system("Rscript Make_Dice_NJ_Tree.R $dice_file $tree_file");
	system("rm -f Make_Dice_NJ_Tree.R");
}

sub calc_scores {
	my $hit_counts = 0;
	my $passed_hit_counts = 0;
	my $shouter = 1;
	my %scores;
	
	#Collect info on hits from the m8 blast formatted file 
	print "Parsing $m8_file\n";
	open IN, "< $m8_file"  or die "$!";
	while (my $line = <IN>) {
		$hit_counts++;
		if ($hit_counts == $shouter) {print "Processed $hit_counts hits\n"; $shouter += $shouter }
		chomp $line;
		my @values = split /\t/, $line;
		#Ignore hits with less than 30% id, less than 30 of alignment length and evalue higher than 0.01
		next if (($values[2] < 30) or ($values[3] < 30) or ($values[10] > 0.01));
		$passed_hit_counts++;
		#Change PEG names to scaffold names
		$values[0] =~ s/_(\d)+$//;
		$values[1] =~ s/_(\d)+$//;
		#Add to total scores
		$scores{$values[0]}{$values[1]} += $values[11];
	}

	my $perc_passed = int(($passed_hit_counts/$hit_counts)*100);
	print "$passed_hit_counts out of $hit_counts ($perc_passed%) hits passed\n";

	print "Computing Dice distances\n";
	$shouter = 1;
	my $combo_counts = 0;
	my %dice;
	my %beenthere;
	my $missing_count = 0;

	foreach my $genomeA (keys %scores) {
		#Check if ther eare any genomes lacking self hits and skip then
		unless (defined $scores{$genomeA}{$genomeA}) { $missing_count++; next}
		foreach my $genomeB (keys %{$scores{$genomeA}}) {
			#Distances must be symmetric, once distances between a pair is calculated, skip other calculations
			next if (defined $beenthere{$genomeA}{$genomeB});
			unless (defined $scores{$genomeB}{$genomeB}) { next}
			
			$combo_counts++;
			if ($combo_counts == $shouter) {print "Processed $combo_counts combinations\n"; $shouter += $shouter }
			
			if ($genomeA eq $genomeB) {
				$dice{$genomeA}{$genomeB} = 0;
				next;
			}
			
			#Calc Dice distances between pairs. Correct if distance is below 0
			my $dist = 1 - ( 2*($scores{$genomeA}{$genomeB}) / ($scores{$genomeA}{$genomeA} + $scores{$genomeB}{$genomeB}) );
			$dist = 0 if ($dist < 0);
			
			$dice{$genomeA}{$genomeB} = $dist;
			$dice{$genomeB}{$genomeA} = $dist;
			
			$beenthere{$genomeB}{$genomeA} = 1;
		}
}

	print "$missing_count genomes ignored due to lack of self scores\n";

	#Print table output
	$dice_file = $file_prefix."_Dice_Distances.tsv";
	open OUT, "> $dice_file" or die "$!";
	my @genomes_list = sort keys %scores;
	my $genome_count = @genomes_list;

	print "Printing distances between $genome_count genomes to $dice_file\n";
	foreach my $genomeA (@genomes_list) {print OUT "\t$genomeA" };
	print OUT "\n";

	foreach my $genomeA (@genomes_list) {
		print OUT $genomeA;
		foreach my $genomeB (@genomes_list) {
			my $dist = 1;
			$dist = $dice{$genomeA}{$genomeB} if (defined $dice{$genomeA}{$genomeB});
			print OUT "\t$dist";
		}
		print OUT "\n";
	}
	close OUT;
}

sub call_diamond {
	print "Running Diamond\n";
	system("diamond makedb --in $pegs_file_1 --db $pegs_file_1");
	$m8_file = $file_prefix."_PEGs-x-Self_BLOSUM45_MS.blastp";
	system("diamond blastp --matrix BLOSUM45 --threads $threads --more-sensitive --db $pegs_file_1 --outfmt 6 --query $pegs_file_1 --max-target-seqs 999999 --id 30 --evalue 0.001 --out $m8_file");
}

sub index_genome_seqs {
	print "Indexing sequences from $genomes_file_1\n";
	my %seen_ids;
	my $seq_in = Bio::SeqIO->new('-file' => "< $genomes_file_1", '-format' => "Fasta");
	my $counter = 0;
	while (my $seq_obj = $seq_in->next_seq) {
			$counter++;
			my $id = $seq_obj->id();
			my $length = $seq_obj->length;
			my $desc = $seq_obj->desc();
			
			$seq_info{"Length"}{$id} = $length;
			$seq_info{"Description"}{$id} = $desc;
			
			die "Repeated id for sequence #$counter. Id: $id\n" if (defined $seen_ids{$id});
			$seen_ids{$id} = 1;
		}	

}

sub index_peg_seqs {
	my $pegs_file = $_[0];
	print "Indexing sequences from $pegs_file\n";
	my %seen_ids;
	my $seq_in = Bio::SeqIO->new('-file' => "< $pegs_file", '-format' => "Fasta");
	my $counter = 0;
	while (my $seq_obj = $seq_in->next_seq) {
			$counter++;
			my $id = $seq_obj->id();
			die "Repeated id for sequence #$counter. Id: $id\n" if (defined $seen_ids{$id});
			$seen_ids{$id} = 1;
			
			my $genome = $id;
			$genome =~ s/_(\d)+$//;

			$seq_info{"PEG_Count"}{$genome}++;
		}	

}
	
sub call_prodigal {
	$pegs_file_1 = $file_prefix."_PEGs";
	print "Running Prodigal\n";
	system("prodigal -q -n -p meta -a $pegs_file_1.faa -d $pegs_file_1.fna -f gff -i $genomes_file_1 -o $pegs_file_1.gff");
	$pegs_file_1 = $pegs_file_1.".faa";
}


sub read_table {
#Reads a table as a 2D hash. Columns are the first dimension and rows the second. Receives a reference of a hash as the parameters to run the subroutine  
	my %parameters	= %{$_[0]};
	die "No Input File Defined.\n" unless (defined $parameters{"file"});
	my $file = $parameters{"file"};
	my $sep = "\t";
	$sep = $parameters{"separator"} if (defined $parameters{"separator"});	
	
	my %matrix;

	open INPUT, "< $file" or die "$!";
	my $header = <INPUT>;
	$header =~ s/\r$//;
	chomp $header;
	my @cols = split /$sep/, $header;
	
	my $values_count;
	while (my $line = <INPUT>) {
		#Read each line and assign it to the 2D hash
		$line =~ s/\r$//;
		chomp $line;
		my @rows = split /$sep/, $line;
		foreach my $posit (1..(@cols - 1)) {
			$matrix{$cols[$posit]}{$rows[0]} = $rows[$posit];
			$values_count++;
		}
	}
	close INPUT;
	print "Obtained $values_count values from $file.\n";
	return \%matrix;
}


sub print_matrix {
    my %parameters  = %{$_[0]};
         
    die "No Matrix (2D Hash) Defined.\n" unless (defined $parameters{"matrix"});
    my %matrix = %{$parameters{"matrix"}};  
    my $output_file = "Output_Matrix";
    my $sep = "\t"; 
     
    $output_file = $parameters{"file"} if (defined $parameters{"file"});
    $sep = $parameters{"separator"} if (defined $parameters{"separator"});      
 
     
    my $rows_ref = list_level2(\%matrix);
    my %rows = %{$rows_ref};
 
    open OUTPUT, "> $output_file" or die "$!";   
    print OUTPUT "Variable";
    #print the Header   
    foreach my $col (sort keys %matrix) {
        print OUTPUT "$sep"."$col";
        }
    print OUTPUT "\n";
    #print the row names followed by the values and a line break
    foreach my $row (sort keys %rows) {
        print OUTPUT "$row";
        foreach my $col (sort keys %matrix) {
            if (defined $matrix{$col}{$row}) {print OUTPUT "$sep"."$matrix{$col}{$row}"} else {print OUTPUT "$sep"."NA"};
        }
    print OUTPUT "\n";
    }
    close OUTPUT;
}
 
sub list_level2 {
    #Receives a reference to a 2D hash. returns a reference to a 1D hash in which the keys are all the keys from the 2nd dimesion of the input hash 
    my %hash = %{$_[0]};
    my %list;   
    foreach my $param1 (keys %hash) {
        foreach my $param2 (keys %{$hash{$param1}}) {
            $list{$param2} = 1;
        }
    }
    return \%list;
}



